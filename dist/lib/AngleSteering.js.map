{"version":3,"sources":["../../src/lib/AngleSteering.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;AAEA,IAAI,MAAM,QAAN;AACJ,IAAI,MAAM,CAAC,QAAD;;IAEW;;;AACnB,WADmB,aACnB,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC;0BADf,eACe;;uEADf,0BAGX,MAAM,OAAO,UAFa;;AAIhC,UAAK,IAAL,GAAY,IAAZ,CAJgC;AAKhC,UAAK,KAAL,GAAa,KAAb;;;AALgC,SAQhC,CAAK,IAAL,GAAY,MAAK,IAAL,CAAU,IAAV,OAAZ,CARgC;;GAAlC;;eADmB;;yBAYd,UAAU;;;AAEb,iCAdiB,4DAcG,UAAU,UAAC,KAAD,EAAQ,MAAR,EAAmB;;AAE/C,YAAI,OAAO,OAAO,IAAP;YAEP,WAAW,MAAM,KAAN,CAAY,CAAZ,EAAe,IAAf,EAAX;;;;AAGA,eAAO,WAAW,IAAX,GAAkB,KAAK,GAAL,CAAS,QAAT,EAAmB,CAAnB,CAAlB,GAA0C,KAAK,GAAL,CAAS,QAAT,EAAmB,CAAC,CAAD,CAAnB,GAAuB,CAAvB;YAEjD,MAAM,OAAO,IAAP,8BAvBK,uDAuBL,8BAvBK,sDAuBL,CATqC;;AAW/C,YAAG,OAAK,IAAL,EAAW;;AAEZ,iBAAK,IAAL,GAAY,KAAZ,CAFY;;AAIZ,cAAI,WAAW,KAAK,KAAL,CAAY,KAAK,GAAL,CAAS,CAAC,IAAE,KAAK,GAAL,CAAS,IAAT,EAAe,CAAf,CAAF,CAAD,GAAsB,GAAtB,CAArB,CAAX,CAJQ;;AAMZ,qCA/Ba,2DA+BE,KAAK,OAAK,KAAL,EAAY,YAAM;;;;AAIpC,gBAAI,WAAW,KAAK,KAAL,CAAY,KAAK,GAAL,CAAS,CAAC,IAAE,KAAK,GAAL,CAAS,IAAT,EAAe,CAAf,CAAF,CAAD,GAAsB,GAAtB,CAArB,CAAX,CAJgC;;AAMpC,oBAAQ,GAAR,CAAY,eAAe,QAAf,CAAZ;;;;AANoC,gBAUhC,4CAA6C,QAA7C,CAVgC;;AAYpC,uBAAW,YAAM;AACf,qBAAK,IAAL,GAAY,IAAZ,CADe;aAAN,EAER,IAFH,EAZoC;WAAN,CAAhC,CANY;SAAd;OAX4B,CAA9B,CAFa;;;;SAZI","file":"AngleSteering.js","sourcesContent":["import AbstractSteering from './AbstractSteering';\n\nlet min = Infinity\nlet max = -Infinity;\n\nexport default class AngleSteering extends AbstractSteering {\n  constructor(left, right, options) {\n\n    super(left, right, options);\n\n    this.pass = true;\n    this.block = false;\n\n    //Bind class functions to the prototype of this class.\n    this.turn = this.turn.bind(this);\n  }\n\n  turn(rawFrame) {\n\n    super.calibrateHand(rawFrame, (frame, zeroes) => {\n\n      let zero = zeroes.roll,\n\n          handRoll = frame.hands[0].roll(),\n\n          //Normalize roll\n          roll = handRoll > zero ? Math.min(handRoll, 1) : Math.max(handRoll, -2)/2,\n\n          key = roll < zero ? super.right() : super.left();\n\n      if(this.pass) {\n\n        this.pass = false;\n\n        let waitTime = Math.floor((Math.abs((1-Math.pow(roll, 2))*200)));\n\n        super.keyPress(key, this.block, () => {\n\n          //console.log(roll);\n\n          let waitTime = Math.floor((Math.abs((1-Math.pow(roll, 2))*200)));\n\n          console.log(\"waitTime: \" + waitTime)\n\n          //this.block = waitTime > 190;\n\n          let wait = /*this.block || waitTime < 10 ? 0 :*/ waitTime\n\n          setTimeout(() => {\n            this.pass = true;\n          }, wait);\n          \n        });\n      }\n    });\n  }\n}\n\n/*turn(rawFrame) {\n\n    super.calibrateHand(rawFrame, (frame, zeroes) => {\n\n      let zero = zeroes.handDirection[0];\n\n      let direction = frame.hands[0].direction[0] || undefined;\n\n      let key = direction < this.zero ? super.left() : super.right();\n\n      if(this.pass) {\n\n        this.pass = false;\n        super.keyPress(key, () => {\n\n          let waitTime = Math.floor((Math.abs((1-Math.pow(direction, 2))*200)));\n\n          console.log(\"waitTime: \" + waitTime)\n\n          let wait = waitTime < 45 ? 0 : waitTime\n\n          setTimeout(() => {\n            this.pass = true;\n          }, wait);\n          \n        });\n      }\n    });\n  }\n*/"]}